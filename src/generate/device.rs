use crate::svd::{derive_from::DeriveFrom, Device};
use anyhow::Result;

use proc_macro2::{Ident, Span, TokenStream};
use quote::{quote, ToTokens};

use crate::generate::{
    interrupt,
    peripheral::{self, PeripheralRendered},
};
use crate::util::{self, ToSanitizedSnakeCase};

use log::info;

use std::collections::HashMap;

pub fn render(d: &Device, device_x: &mut String) -> Result<TokenStream> {
    let mut out = TokenStream::new();

    let doc = format!(
        "Peripheral access API for {0} microcontrollers \
         (generated using svd2mmio-ll-rs v{1})\n\n\
         You can find an overview of the generated API [here].\n\n\
         API features to be included in the [next] svd2mmio-ll-rs \
         release can be generated by cloning the svd2mmio-ll-rs [repository], \
         checking out the above commit, and running `cargo doc --open`.\n\n\
         [here]: https://docs.rs/svd2mmio-ll-rs/{1}/svd2mmio-ll-rs/#peripheral-api\n\
         [next]: https://github.com/no111u3/svd2mmio-ll-rs/blob/master/CHANGELOG.md#unreleased\n\
         [repository]: https://github.com/no111u3/svd2mmio-ll-rs",
        d.name.to_uppercase(),
        env!("CARGO_PKG_VERSION")
    );

    out.extend(quote! {
        #![doc = #doc]
        // Deny a subset of warnings
        #![deny(const_err)]
        #![deny(dead_code)]
        #![deny(improper_ctypes)]
        #![deny(missing_docs)]
        #![deny(no_mangle_generic_items)]
        #![deny(non_shorthand_field_patterns)]
        #![deny(overflowing_literals)]
        #![deny(path_statements)]
        #![deny(patterns_in_fns_without_body)]
        #![deny(private_in_public)]
        #![deny(unconditional_recursion)]
        #![deny(unused_allocation)]
        #![deny(unused_comparisons)]
        #![deny(unused_parens)]
        #![deny(while_true)]
        // Explicitly allow a few warnings that may be verbose
        #![allow(non_camel_case_types)]
        #![allow(non_snake_case)]
        #![no_std]
    });

    out.extend(quote! {
        use core::ops::Deref;
        use core::marker::PhantomData;
    });

    // Retaining the previous assumption
    let mut fpu_present = true;

    if let Some(cpu) = d.cpu.as_ref() {
        let bits = util::unsuffixed(u64::from(cpu.nvic_priority_bits));

        out.extend(quote! {
            ///Number available in the NVIC for configuring priority
            pub const NVIC_PRIO_BITS: u8 = #bits;
        });

        fpu_present = cpu.fpu_present;
    }

    info!(
        "CPU {} FPU",
        if fpu_present { "has" } else { "does not have" }
    );

    out.extend(interrupt::render(&d.peripherals, device_x)?);

    let core_peripherals: &[_] = if fpu_present {
        &[
            "CBP", "CPUID", "DCB", "DWT", "FPB", "FPU", "ITM", "MPU", "NVIC", "SCB", "SYST", "TPIU",
        ]
    } else {
        &[
            "CBP", "CPUID", "DCB", "DWT", "FPB", "ITM", "MPU", "NVIC", "SCB", "SYST", "TPIU",
        ]
    };

    out.extend(quote! {
        pub use cortex_m::peripheral::Peripherals as CorePeripherals;
        #[cfg(feature = "rt")]
        pub use cortex_m_rt::interrupt;
        #[cfg(feature = "rt")]
        pub use self::Interrupt as interrupt;
    });

    if fpu_present {
        out.extend(quote! {
            pub use cortex_m::peripheral::{
                CBP, CPUID, DCB, DWT, FPB, FPU, ITM, MPU, NVIC, SCB, SYST, TPIU,
            };
        });
    } else {
        out.extend(quote! {
            pub use cortex_m::peripheral::{
                CBP, CPUID, DCB, DWT, FPB, ITM, MPU, NVIC, SCB, SYST, TPIU,
            };
        });
    }

    let generic_file = std::str::from_utf8(include_bytes!("generic.rs"))?;

    let tokens = syn::parse_file(generic_file)?.into_token_stream();

    out.extend(quote! {
        #[allow(unused_imports)]
        use generic::*;
        ///Common register and bit access and modify traits
        pub mod generic {
            #tokens
        }
    });

    let mut peripherals: HashMap<String, PeripheralRendered> = HashMap::new();

    for p in &d.peripherals {
        if core_peripherals.contains(&&*p.name.to_uppercase()) {
            // Core peripherals are handled above
            continue;
        }

        let p_derivedfrom = p
            .derived_from
            .as_ref()
            .and_then(|s| d.peripherals.iter().find(|x| x.name == *s));
        let p_merged = p_derivedfrom.map(|ancestor| p.derive_from(ancestor));
        let p = p_merged.as_ref().unwrap_or(p);

        if let (Some(df), None) = (p.derived_from.as_ref(), &p_derivedfrom) {
            eprintln!(
                "Couldn't find derivedFrom original: {} for {}, skipping",
                df, p.name
            );
            return Ok(out);
        }

        let peripheral = peripheral::render(p, &d.peripherals, &d.default_register_properties)?;
        if let Some(peripheral_old) = peripherals.get_mut(&peripheral.namespace) {
            let PeripheralRendered {
                registers,
                address,
                namespace: _,
            } = peripheral;
            peripheral_old.registers.extend(registers);
            peripheral_old.address.extend(address);
        } else {
            peripherals.insert(peripheral.namespace.clone(), peripheral);
        }

        if p.registers
            .as_ref()
            .map(|v| &v[..])
            .unwrap_or(&[])
            .is_empty()
            && p.derived_from.is_none()
        {
            // No register block will be generated so don't put this peripheral
            // in the `Peripherals` struct
            continue;
        }
    }

    let span = Span::call_site();

    for (
        _,
        PeripheralRendered {
            registers,
            address,
            namespace,
        },
    ) in peripherals
    {
        let name_sc = Ident::new(&namespace.to_sanitized_snake_case(), span);

        out.extend(quote! {
            pub mod #name_sc {
                #registers

                #address
            }
        })
    }

    Ok(out)
}
